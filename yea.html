<!DOCTYPE html>
<html>
<head>
    <title>Cessna Flight Game with Fixed Camera</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        Controls:<br>
        W: Increase Throttle<br>
        S: Decrease Throttle<br>
        A/D: Roll Left/Right<br>
        Arrow Up/Down: Pitch<br>
        Arrow Left/Right: Yaw<br>
        Space: Shoot Bombs
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Ground and runway
        const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
        const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x228B22 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const runwayGeometry = new THREE.PlaneGeometry(20, 200);
        const runwayMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
        const runway = new THREE.Mesh(runwayGeometry, runwayMaterial);
        runway.rotation.x = -Math.PI / 2;
        runway.position.y = 0.01;
        scene.add(runway);

        // Trees
        function createTree(x, z) {
            const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 8);
            const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, 1, z);

            const foliageGeometry = new THREE.ConeGeometry(1.5, 3, 8);
            const foliageMaterial = new THREE.MeshBasicMaterial({ color: 0x006400 });
            const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
            foliage.position.set(x, 2.5, z);

            scene.add(trunk);
            scene.add(foliage);
        }

        for (let i = 0; i < 50; i++) {
            const x = Math.random() * 1000 - 500;
            const z = Math.random() * 1000 - 500;
            if (Math.abs(x) > 15 || Math.abs(z) > 100) {
                createTree(x, z);
            }
        }

        // Sky and fog
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        // Plane
        const planeGroup = new THREE.Group();
        const bodyGeometry = new THREE.BoxGeometry(2, 0.5, 5);
        const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        planeGroup.add(body);
        const wingGeometry = new THREE.BoxGeometry(6, 0.1, 1);
        const wingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const wings = new THREE.Mesh(wingGeometry, wingMaterial);
        wings.position.y = 0.2;
        planeGroup.add(wings);
        const tailGeometry = new THREE.BoxGeometry(1, 0.1, 2);
        const tail = new THREE.Mesh(tailGeometry, wingMaterial);
        tail.position.z = -2;
        tail.position.y = 0.2;
        planeGroup.add(tail);
        const vertTailGeometry = new THREE.BoxGeometry(0.1, 1, 1);
        const vertTail = new THREE.Mesh(vertTailGeometry, wingMaterial);
        vertTail.position.z = -2.5;
        vertTail.position.y = 0.7;
        planeGroup.add(vertTail);
        scene.add(planeGroup);
        planeGroup.position.set(0, 0.25, 90);

        // Audio
        const listener = new THREE.AudioListener();
        camera.add(listener);
        
        const takeoffSound = new THREE.Audio(listener);
        const flySound = new THREE.Audio(listener);
        
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load('https://www.soundjay.com/transportation/sounds/airplane-take-off-01.mp3', function(buffer) {
            takeoffSound.setBuffer(buffer);
            takeoffSound.setLoop(false);
            takeoffSound.setVolume(0.5);
        });
        audioLoader.load('https://www.soundjay.com/transportation/sounds/airplane-flyby-01.mp3', function(buffer) {
            flySound.setBuffer(buffer);
            flySound.setLoop(true);
            flySound.setVolume(0.3);
        });

        // Weather system
        class Weather {
            constructor() {
                this.clouds = [];
                this.rainParticles = [];
                this.wind = new THREE.Vector3(0.1, 0, 0.05);
                this.createClouds();
                this.createRain();
            }

            createClouds() {
                const cloudGeometry = new THREE.SphereGeometry(5, 8, 8);
                const cloudMaterial = new THREE.MeshBasicMaterial({
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.6
                });

                for (let i = 0; i < 20; i++) {
                    const cloud = new THREE.Mesh(cloudGeometry, cloudMaterial);
                    cloud.position.set(
                        Math.random() * 1000 - 500,
                        Math.random() * 20 + 10,
                        Math.random() * 1000 - 500
                    );
                    cloud.scale.set(
                        Math.random() * 2 + 1,
                        Math.random() * 1 + 0.5,
                        Math.random() * 2 + 1
                    );
                    this.clouds.push(cloud);
                    scene.add(cloud);
                }
            }

            createRain() {
                const rainGeometry = new THREE.BufferGeometry();
                const rainCount = 1000;
                const positions = new Float32Array(rainCount * 3);
                const velocities = new Float32Array(rainCount * 3);

                for (let i = 0; i < rainCount; i++) {
                    positions[i * 3] = Math.random() * 100 - 50;
                    positions[i * 3 + 1] = Math.random() * 50;
                    positions[i * 3 + 2] = Math.random() * 100 - 50;
                    velocities[i * 3 + 1] = -(Math.random() * 0.2 + 0.1);
                }

                rainGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const rainMaterial = new THREE.PointsMaterial({
                    color: 0xaaaaaa,
                    size: 0.1,
                    transparent: true
                });
                const rain = new THREE.Points(rainGeometry, rainMaterial);
                this.rainParticles = { mesh: rain, velocities: velocities };
                scene.add(rain);
            }

            update() {
                this.clouds.forEach(cloud => {
                    cloud.position.add(this.wind.clone().multiplyScalar(0.01));
                    if (cloud.position.x > 500) cloud.position.x = -500;
                });

                const positions = this.rainParticles.mesh.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3] += this.wind.x * 0.05;
                    positions[i * 3 + 1] += this.rainParticles.velocities[i * 3 + 1] + this.wind.y * 0.05;
                    positions[i * 3 + 2] += this.wind.z * 0.05;

                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3 + 1] = 50;
                        positions[i * 3] = planeGroup.position.x + Math.random() * 100 - 50;
                        positions[i * 3 + 2] = planeGroup.position.z + Math.random() * 100 - 50;
                    }
                }
                this.rainParticles.mesh.geometry.attributes.position.needsUpdate = true;
            }
        }

        const weather = new Weather();

        // Fixed camera position - adjusted to view plane
        camera.position.set(30, 20, 110); // Positioned to see runway start and takeoff
        camera.lookAt(new THREE.Vector3(0, 0, 50)); // Looking at midpoint of runway

        // Realistic flight physics
        let throttle = 0;
        let airspeed = 0;
        const maxThrust = 0.03;
        const gravity = 0.002;
        const liftCoefficient = 0.02;
        const dragCoefficient = 0.001;
        let angleOfAttack = 0;
        let roll = 0;
        let pitch = 0;
        let yaw = 0;
        const rotationSpeed = 0.02;
        let isAirborne = false;

        // Bombs array
        const bombs = [];

        // Controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.key.toLowerCase()] = true);
        document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);

        function createBomb() {
            const bombGeometry = new THREE.SphereGeometry(0.2, 32, 32);
            const bombMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
            bomb.position.copy(planeGroup.position);
            bomb.velocity = new THREE.Vector3(0, -0.3, -0.5).add(weather.wind.clone().multiplyScalar(0.1));
            scene.add(bomb);
            bombs.push(bomb);
        }

        function updateBombs() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                bomb.position.add(bomb.velocity);
                if (bomb.position.y < 0) {
                    scene.remove(bomb);
                    bombs.splice(i, 1);
                }
            }
        }

        function updatePlane() {
            if (keys['w']) throttle = Math.min(throttle + 0.01, 1);
            if (keys['s']) throttle = Math.max(throttle - 0.01, 0);
            if (keys['a']) roll = Math.min(roll + rotationSpeed, Math.PI/4);
            if (keys['d']) roll = Math.max(roll - rotationSpeed, -Math.PI/4);
            if (keys['arrowup']) pitch = Math.max(pitch - rotationSpeed, -Math.PI/4);
            if (keys['arrowdown']) pitch = Math.min(pitch + rotationSpeed, Math.PI/4);
            if (keys['arrowleft']) yaw += rotationSpeed;
            if (keys['arrowright']) yaw -= rotationSpeed;
            if (keys[' ']) {
                createBomb();
                keys[' '] = false;
            }

            const thrust = throttle * maxThrust;
            const lift = airspeed * liftCoefficient * Math.sin(angleOfAttack);
            const drag = airspeed * airspeed * dragCoefficient;
            
            airspeed += thrust - drag;
            airspeed = Math.max(0, airspeed);
            
            const windEffect = weather.wind.clone().multiplyScalar(0.01);
            planeGroup.position.add(windEffect);

            const direction = new THREE.Vector3(0, 0, -1)
                .applyQuaternion(planeGroup.quaternion)
                .multiplyScalar(airspeed);
            
            let verticalSpeed = lift - gravity;
            if (planeGroup.position.y <= 0.25 && verticalSpeed < 0) {
                verticalSpeed = 0;
                if (airspeed > 0.2 && throttle > 0.5 && !isAirborne) {
                    isAirborne = true;
                    if (!takeoffSound.isPlaying) takeoffSound.play();
                }
            }
            
            planeGroup.position.add(direction);
            planeGroup.position.y = Math.max(0.25, planeGroup.position.y + verticalSpeed);

            if (isAirborne && !flySound.isPlaying) flySound.play();
            if (!isAirborne && flySound.isPlaying) flySound.stop();

            angleOfAttack = pitch * 0.5;

            planeGroup.rotation.order = 'YXZ';
            planeGroup.rotation.x = pitch;
            planeGroup.rotation.z = roll;
            planeGroup.rotation.y = yaw;

            roll *= 0.95;
            pitch *= 0.95;
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlane();
            updateBombs();
            weather.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>